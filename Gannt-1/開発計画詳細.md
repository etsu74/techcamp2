# 依存関係矢印表示 - 段階的実装計画詳細

## プロジェクト概要
マンション修繕計画ガントチャートアプリにおける依存関係矢印表示機能の段階的実装計画

**作成日**: 2025-08-22  
**対象機能**: Phase-1A-3 依存関係矢印表示  
**技術基盤**: Frappe Gantt v0.6.1 + 3層SVGレイヤーアーキテクチャ  

---

## 技術アーキテクチャ - 3層SVGレイヤー構造

### **Layer 1: Frappe Gantt基盤SVG** ✅ (既存完成)
```javascript
// Frappe Gantt v0.6.1が自動生成
- 工事イベントのバー表示
- タイムライン・グリッド・基本UI要素
- 標準的なガントチャート機能
```

### **Layer 2: 会議イベント◆マークレイヤー** ✅ (実装完成)
```javascript
// gantt-manager.js:356-400行目 実装済み
const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
ganttInstance.$svg.appendChild(diamond);

// 機能: 同一線上複数◆マーク表示（総会・理事会・修繕委員会）
// 実装状況: Phase-1A-2完成・動作確認済み
```

### **Layer 3: 依存関係矢印レイヤー** 🔄 (次期実装対象)
```javascript
// 新規実装予定
const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
ganttInstance.$svg.appendChild(arrow);
ganttInstance.$svg.appendChild(arrowHead);

// 機能: 工事間依存関係矢印表示（先行工事右端 → 後続工事左端）
// 実装状況: Phase-1A-3実装予定
```

---

## 段階的実装計画

### **Stage 1: 現状分析・技術課題整理** ✅

#### **現在の依存関係表示状況**
- **Frappe Gantt v0.6.1**: 三角形塗りつぶし表示（△）
- **要件**: 先行工事右端 → 後続工事左端への矢印ライン（→）
- **技術限界**: Frappe Gantt標準では矢印ライン表示不可

#### **v1.0.3実験結果** (実験ブランチ: `frappe-latest-rebuild`)
- ✅ 基本機能互換性確認済み
- ❌ 依存関係表示は同様に三角形のまま
- **結論**: バージョンアップでは解決不可

---

### **Stage 2: カスタム矢印描画アーキテクチャ設計**

#### **技術方式選択: ハイブリッド方式（推奨）**
```javascript
// Frappe標準機能 + カスタムSVG overlayアプローチ
// Layer 1 (Frappe) + Layer 2 (会議) + Layer 3 (矢印)

// 座標取得システム（Layer 2の成功パターンを継承）
class SVGCoordinateHelper {
    static getTaskBounds(ganttInstance, taskId) {
        const element = ganttInstance.$svg.querySelector(`[data-id="${taskId}"]`);
        return element ? element.getBBox() : null;
    }
    
    static getTaskConnectionPoint(ganttInstance, taskId, position) {
        const bounds = this.getTaskBounds(ganttInstance, taskId);
        if (!bounds) return null;
        
        const points = {
            'left': { x: bounds.x, y: bounds.y + bounds.height / 2 },
            'right': { x: bounds.x + bounds.width, y: bounds.y + bounds.height / 2 },
            'center': { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height / 2 }
        };
        
        return points[position];
    }
}
```

#### **座標計算ロジック**
```javascript
function calculateArrowPath(predecessorId, successorId) {
    // 1. 先行タスク右端座標取得 (Layer 2パターンの発展)
    const startPoint = SVGCoordinateHelper.getTaskConnectionPoint(
        ganttInstance, predecessorId, 'right'
    );
    
    // 2. 後続タスク左端座標取得  
    const endPoint = SVGCoordinateHelper.getTaskConnectionPoint(
        ganttInstance, successorId, 'left'
    );
    
    // 3. 矢印パス計算（L字型推奨）
    return generateLShapedArrowPath(startPoint, endPoint);
}
```

---

### **Stage 3: 段階的実装プラン**

#### **Phase 3.1: 座標取得システム** (実装時間: 1-2時間)
```javascript
// gantt-manager.js に追加
class DependencyArrowRenderer {
    constructor(ganttInstance) {
        this.gantt = ganttInstance;
        this.svgContainer = ganttInstance.$svg;
        this.arrowElements = []; // 矢印要素管理用
    }
    
    // Frappe Ganttから座標情報を抽出（Layer 2の成功パターン継承）
    extractTaskPositions() {
        const tasks = this.gantt.tasks;
        const positions = {};
        
        tasks.forEach(task => {
            const element = this.svgContainer.querySelector(`[data-id="${task.id}"]`);
            if (element) {
                const rect = element.getBBox();
                positions[task.id] = {
                    left: rect.x,
                    right: rect.x + rect.width,
                    top: rect.y + rect.height/2,
                    width: rect.width,
                    height: rect.height
                };
            }
        });
        
        return positions;
    }
}
```

#### **Phase 3.2: SVG矢印描画エンジン** (実装時間: 1-2時間)
```javascript
// 矢印SVGパス生成
renderDependencyArrows(dependencies, positions) {
    // 既存矢印要素をクリア
    this.clearExistingArrows();
    
    dependencies.forEach(dep => {
        const predecessor = positions[dep.from];
        const successor = positions[dep.to];
        
        if (predecessor && successor) {
            // L字型矢印パス計算
            const pathData = this.calculateLShapedArrow(
                predecessor.right, predecessor.top,
                successor.left, successor.top
            );
            
            // SVG矢印要素作成・追加
            const arrowElement = this.createArrowElement(pathData, dep);
            this.svgContainer.appendChild(arrowElement);
            this.arrowElements.push(arrowElement);
            
            console.log(`依存関係矢印描画: ${dep.from} → ${dep.to}`);
        }
    });
}

calculateLShapedArrow(x1, y1, x2, y2) {
    const midX = x1 + (x2 - x1) * 0.7; // 中間点をやや右寄りに
    const arrowHeadSize = 8;
    
    // 矢印本体パス (L字型)
    const linePath = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2 - arrowHeadSize} ${y2}`;
    
    // 矢印先端パス
    const arrowHead = `M ${x2 - arrowHeadSize} ${y2 - arrowHeadSize/2} L ${x2} ${y2} L ${x2 - arrowHeadSize} ${y2 + arrowHeadSize/2}`;
    
    return { linePath, arrowHead };
}

createArrowElement(pathData, dependency) {
    // 矢印ライン作成
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    line.setAttribute('d', pathData.linePath);
    line.setAttribute('stroke', '#666');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('fill', 'none');
    line.setAttribute('marker-end', 'url(#arrowhead)');
    line.classList.add('dependency-arrow');
    line.setAttribute('data-dependency', `${dependency.from}-${dependency.to}`);
    
    // 矢印先端作成
    const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    arrowHead.setAttribute('d', pathData.arrowHead);
    arrowHead.setAttribute('fill', '#666');
    arrowHead.classList.add('dependency-arrow-head');
    
    // グループ化して返す
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.appendChild(line);
    group.appendChild(arrowHead);
    
    return group;
}
```

#### **Phase 3.3: 動的更新システム** (実装時間: 1時間)
```javascript
// Frappe Gantt更新イベントとの同期
setupDynamicUpdate() {
    // 1. ガントチャート再描画検知
    const observer = new MutationObserver(() => {
        console.log('Frappe Gantt DOM変更検知 - 矢印再描画');
        setTimeout(() => this.refreshArrows(), 100);
    });
    
    observer.observe(this.svgContainer, {
        childList: true,
        subtree: true,
        attributes: true
    });
    
    // 2. スクロール・ズーム対応
    this.gantt.container.addEventListener('scroll', () => {
        this.updateArrowPositions();
    });
    
    // 3. 表示モード切替対応
    window.addEventListener('viewModeChanged', () => {
        console.log('表示モード変更 - 矢印再計算');
        setTimeout(() => this.recalculateAndRedraw(), 200);
    });
}

refreshArrows() {
    const positions = this.extractTaskPositions();
    const dependencies = this.parseDependenciesFromData();
    this.renderDependencyArrows(dependencies, positions);
}

clearExistingArrows() {
    this.arrowElements.forEach(element => {
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    });
    this.arrowElements = [];
}
```

---

### **Stage 4: 実装統合・テスト** (実装時間: 30分)

#### **Phase 4.1: データフロー統合**
```javascript
// main.js での統合実装
function initializeDependencySystem(ganttInstance) {
    const arrowRenderer = new DependencyArrowRenderer(ganttInstance);
    
    // Frappe Gantt初期化完了後に矢印描画
    ganttInstance.on('ready', () => {
        console.log('Frappe Gantt初期化完了 - 依存関係矢印システム開始');
        arrowRenderer.initialize();
        arrowRenderer.setupDynamicUpdate();
        arrowRenderer.renderAllArrows();
    });
    
    return arrowRenderer;
}
```

#### **Phase 4.2: 19列統合フォーマット対応** (実装時間: 30分)
```javascript
// dependencies列の解析強化
function parseDependencies(dependencyString) {
    if (!dependencyString) return [];
    
    return dependencyString.split(',').map(dep => {
        dep = dep.trim();
        
        if (dep.includes(':')) {
            // "T5:T6" → T5からT6への依存関係
            const [from, to] = dep.split(':');
            return { from: from.trim(), to: to.trim(), type: 'explicit' };
        } else {
            // "T5,T6" → T5,T6から現在のタスクへの依存関係
            return { from: dep, to: this.currentTaskId, type: 'implicit' };
        }
    });
}
```

---

### **Stage 5: 実用性向上・最適化** (継続改善)

#### **Phase 5.1: 視覚的改善**
```javascript
// 矢印スタイリング強化
const arrowStyles = {
    default: { stroke: '#666', strokeWidth: 2 },
    critical: { stroke: '#FF4444', strokeWidth: 3 }, // クリティカルパス
    meeting: { stroke: '#FF8C00', strokeWidth: 2, strokeDasharray: '5,5' }, // 会議依存
    delayed: { stroke: '#FF0000', strokeWidth: 3, opacity: 0.8 } // 遅延警告
};

// 重複矢印の自動レイアウト調整
adjustOverlappingArrows(arrows) {
    // 同じ経路の複数矢印を検出し、Y軸オフセットを適用
    const pathGroups = {};
    arrows.forEach(arrow => {
        const pathKey = `${arrow.from}-${arrow.to}`;
        if (!pathGroups[pathKey]) pathGroups[pathKey] = [];
        pathGroups[pathKey].push(arrow);
    });
    
    Object.values(pathGroups).forEach(group => {
        if (group.length > 1) {
            group.forEach((arrow, index) => {
                arrow.yOffset = (index - Math.floor(group.length / 2)) * 10;
            });
        }
    });
}
```

#### **Phase 5.2: パフォーマンス最適化**
```javascript
// 大量データ対応・遅延描画
class PerformanceOptimizer {
    static createBatchRenderer(maxBatchSize = 20) {
        return function renderArrowsBatch(arrows, startIndex = 0) {
            const endIndex = Math.min(startIndex + maxBatchSize, arrows.length);
            
            for (let i = startIndex; i < endIndex; i++) {
                this.renderSingleArrow(arrows[i]);
            }
            
            if (endIndex < arrows.length) {
                // 次のバッチを遅延実行
                requestAnimationFrame(() => {
                    renderArrowsBatch(arrows, endIndex);
                });
            }
        };
    }
    
    // 座標計算結果のキャッシュ
    static createCoordinateCache() {
        const cache = new Map();
        const maxCacheSize = 100;
        
        return {
            get(taskId) {
                return cache.get(taskId);
            },
            
            set(taskId, coordinates) {
                if (cache.size >= maxCacheSize) {
                    const firstKey = cache.keys().next().value;
                    cache.delete(firstKey);
                }
                cache.set(taskId, coordinates);
            },
            
            clear() {
                cache.clear();
            }
        };
    }
}
```

---

## 実装優先順位・スケジュール

### **第1優先: 基本矢印描画機能** (2-3時間)
1. **Phase 3.1** → **Phase 3.2**: 座標取得・基本矢印描画
2. **Phase 4.1**: Frappe Gantt統合

### **第2優先: システム統合** (1時間)
3. **Phase 3.3**: 動的更新対応
4. **Phase 4.2**: 統合フォーマット対応

### **第3優先: 実用性向上** (継続改善)
5. **Phase 5.1**: 視覚的改善・スタイリング
6. **Phase 5.2**: パフォーマンス最適化

---

## 技術的メリット・設計思想

### **1. 実装一貫性**
- **同一API**: Layer 2成功パターンの継承・発展
- **同一手法**: SVGオーバーレイ方式の継続使用
- **座標系統一**: 全レイヤーで統一座標系

### **2. 保守性・拡張性**
- **レイヤー独立性**: 各機能が独立して動作・テスト可能
- **段階的実装**: 基本機能→高度機能の段階的品質向上
- **既存機能保護**: Frappe Gantt・会議表示機能への影響なし

### **3. デバッグ・テスト容易性**
- **Layer別デバッグ**: 問題の局所化が容易
- **座標検証**: `console.log(getBBox())`による座標確認
- **実績のあるアプローチ**: Layer 2の成功実績を基盤とする

---

## 想定課題・対応策

### **課題1: Frappe Ganttバージョン依存**
- **リスク**: DOM構造変更による座標取得失敗
- **対応**: エラーハンドリング・フォールバック機能実装

### **課題2: 大量データ時のパフォーマンス**
- **リスク**: 100+タスク時の描画遅延
- **対応**: バッチ描画・遅延レンダリング実装

### **課題3: 複雑依存関係の視覚的混乱**
- **リスク**: 矢印重複・交差による可読性低下
- **対応**: 自動レイアウト調整・色分け実装

---

## 成功判定基準

### **基本機能 (Phase 3.1-3.2)**
- ✅ 工事イベント間の基本矢印表示
- ✅ 正確な座標計算・接続点表示
- ✅ SVGレイヤー正常動作

### **システム統合 (Phase 3.3-4.2)**  
- ✅ 表示モード切替時の矢印再描画
- ✅ 19列統合フォーマットでの依存関係解析
- ✅ 会議イベントとの共存

### **実用レベル (Phase 5.1-5.2)**
- ✅ 30+タスクでの性能問題なし
- ✅ 視覚的に理解しやすい矢印表示
- ✅ ユーザー操作に対する適切な応答

---

**文書作成**: 2025-08-22  
**最終更新**: 実装開始前  
**対象フェーズ**: Phase-1A-3 依存関係矢印表示  
**技術基盤**: Frappe Gantt v0.6.1 + 3層SVGレイヤーアーキテクチャ

---

## **開発段階の全体構成 (従来計画)**

```
MVP (約2-3週間) → Phase-1A (約2週間) → Phase-1B (約2週間) → Phase-2A (約3週間) → Phase-2B (将来拡張)
```

---

## **MVP段階：基本実装（2-3週間）**

### **MVP-1：環境構築・基盤実装（3-5日）** 🔄 **[Git Commit]**
- [ ] GitHub Codespaces環境セットアップ
- [ ] Frappe Ganttライブラリ導入・動作確認
- [ ] 基本HTML構造作成（ヘッダー、メイン、フッター）
- [ ] CSS基本レイアウト実装
- [ ] プロジェクト構成決定・ファイル配置

**成果物：**
- 基本的なWebページ骨格
- Frappe Gantt表示テスト
- 開発環境構築完了

**コミットメッセージ例：** `feat: 基本環境構築とFrappe Gantt導入完了`

### **MVP-2：データ処理基盤（4-6日）** 🔄 **[Git Commit]**
- [ ] Excel/CSVファイル読み込み機能実装
- [ ] CSVスキーマ検証機能実装
- [ ] Frappe Gantt形式への変換機能実装
- [ ] モックデータでの表示テスト
- [ ] エラーハンドリング基本実装

**成果物：**
- ファイル入出力基盤
- データ変換・検証機能
- エラー処理機能

**コミットメッセージ例：** `feat: Excel/CSV入出力とデータ変換機能実装`

### **MVP-3：ガントチャート基本表示（4-6日）** 🔄 **[Git Commit]**
- [ ] 月表示モードでのガントチャート実装
- [ ] 左カラム固定表示実装
- [ ] 横スクロール機能実装
- [ ] 工事イベントバー表示
- [ ] マイルストーン表示（菱形アイコン）

**成果物：**
- 基本ガントチャート表示
- スクロール機能
- イベント可視化

**コミットメッセージ例：** `feat: 基本ガントチャート表示機能完成`

### **MVP-4：入出力完成・テスト（2-4日）** 🔄 **[Git Commit - MVP完了]**
- [ ] Excel出力機能実装
- [ ] 実データでの動作テスト
- [ ] UI/UX調整
- [ ] バグ修正・安定化
- [ ] MVP機能動作確認

**成果物：**
- 完全動作するMVPアプリ
- テスト済み基本機能
- バグ修正済みコード

**コミットメッセージ例：** `feat: MVP完了 - 基本ガントチャート機能完成`

---

## **Phase-1A：表示機能拡張（2週間）**

### **Phase-1A-1：表示モード実装（4-6日）** ✅ **[Git Commit完了]**
- [x] 日表示モード実装
- [x] 週表示モード実装
- [x] 年表示モード実装（カスタムスケール）
- [x] 表示切替UI実装
- [x] レスポンシブ対応

**成果物：** ✅ **完了済み**
- 全表示モード対応
- 表示切替機能
- レスポンシブUI

**実装確認：** 2025-08-21完了
- main.js:352 表示モード切替機能実装済み
- gantt-manager.js:44-57 各モード別最適化処理実装済み  
- index.html:22-28 表示切替UI実装済み

**コミットメッセージ例：** `feat: 全表示モード（日/週/月/年）実装完了`

### **Phase-1A-2：会議イベント同一線上表示機能（5-7日）** 🚨 **[緊急実装必要]**

#### **2025-08-21 重要課題判明** 
**会議イベント表示要件未達成**:
- **要件定義書130-134行**: 各会議種別ごとに1行、その行内で複数◆マーク表示
- **現状問題**: 15件の会議→15行に分散表示（実用性なし）
- **Frappe Gantt制約**: 1タスク＝1行構造、同一行複数イベント表示は非標準機能
- **緊急度**: 最高（要件の根幹機能）

#### **🚨 緊急実装事項**:
- [ ] **同一線上複数◆マーク表示機能**（最優先・核心機能）
  - 会議種別ごとのデータ集約ロジック実装
  - カスタムSVGレンダリング機能実装
  - Frappe Ganttタスクバー上への◆マーク配置
- [ ] **階層構造チャート表示システム実装**
  - **第1行**: 総会(年1回+臨時) - 意思決定階層最上位
  - **第2行**: 理事会(月1回+臨時) - 中間管理層
  - **第3行**: 修繕委員会(月1回+臨時) - 実行層
  - **第4行目以降**: 工事イベント（開始日基準で行別表示）
- [ ] **時系列◆マーク配置エンジン**
  - 日付ベースでの正確な◆マーク位置計算
  - 重複回避・視認性確保ロジック
- [ ] **会議種別データ統合処理**
  - CSV個別会議データ→会議種別グループ変換
  - 期間設定・頻度設定による自動◆マーク生成
- [ ] **依存関係矢印表示機能**（後回し）
  - Frappe Ganttバージョン問題解決後に実装
  - カスタムSVG矢印実装検討

**🎯 成果物（修正版）：**
- **同一線上複数◆マーク表示機能**（最重要・緊急実装）
- **階層構造チャート表示システム**（意思決定階層反映）
  - 第1-3行：会議イベント（総会→理事会→修繕委員会）
  - 第4行目以降：工事イベント（開始日基準）
- 時系列◆マーク配置エンジン
- 会議種別データ統合処理機能
- 依存関係矢印表示（技術課題解決後）

**🔧 技術仕様（修正版）：**
- **階層構造データ処理**: 要件定義書39行の意思決定階層を反映
  - 総会（Level 1）→ 第1行固定表示
  - 理事会（Level 2）→ 第2行固定表示  
  - 修繕委員会（Level 3）→ 第3行固定表示
- **データ集約**: CSV個別会議→3種別グループ統合処理
- **カスタムレンダリング**: SVG直接操作による◆マーク描画
- **位置計算**: 日付ベース◆マーク位置算出アルゴリズム
- **Frappe Ganttカスタマイズ**: タスクバー上カスタム要素配置
- **ハイブリッド表示**: 会議イベント（固定3行）+ 工事イベント（4行目以降動的行）

**⚠️ 技術的実装課題：**
1. Frappe Gantt標準機能外のカスタマイズ必要
2. SVG要素の動的生成・配置技術
3. 日付スケールとの正確な同期処理
4. レスポンシブ対応での◆マーク位置調整

**コミットメッセージ例：** `feat: 会議イベント同一線上複数◆マーク表示機能実装`

### **Phase-1A-3：統合テスト・調整（2-4日）** 🔄 **[Git Commit - Phase-1A完了]**
- [ ] 全機能統合テスト
- [ ] パフォーマンス最適化
- [ ] UI/UX改善
- [ ] バグ修正・安定化

**成果物：**
- 安定動作する拡張版
- パフォーマンス最適化済み
- UI/UX改善済み

**コミットメッセージ例：** `feat: Phase-1A完了 - 表示機能拡張完成`

---

## **Phase-1B：編集・出力機能（2週間）**

### **Phase-1B-1：編集機能実装（5-7日）** 🔄 **[Git Commit]**
- [ ] ドラッグ&ドロップ編集機能
- [ ] イベント追加・削除機能
- [ ] イベント詳細編集UI
- [ ] 依存関係編集機能
- [ ] 進捗率編集機能

**成果物：**
- 完全編集機能
- 直感的操作UI
- データ整合性保証

**コミットメッセージ例：** `feat: ガントチャート編集機能（ドラッグ&ドロップ等）実装`

### **Phase-1B-2：レポート出力機能（3-5日）** 🔄 **[Git Commit]**
- [ ] PDF出力機能実装
- [ ] Excel詳細レポート出力
- [ ] 印刷用レイアウト最適化
- [ ] レポートテンプレート作成
- [ ] 出力オプション設定

**成果物：**
- PDF/Excel出力機能
- 印刷対応
- レポートテンプレート

**コミットメッセージ例：** `feat: PDF/Excel出力機能とレポートテンプレート実装`

### **Phase-1B-3：最終調整・テスト（2-4日）** 🔄 **[Git Commit - Phase-1完了]**
- [ ] 全機能統合テスト
- [ ] ユーザビリティテスト
- [ ] パフォーマンステスト
- [ ] セキュリティチェック
- [ ] 最終バグ修正

**成果物：**
- 本番利用可能アプリ
- テスト完了版
- ドキュメント整備

**コミットメッセージ例：** `feat: Phase-1完了 - 本番利用可能版完成`

---

## **Phase-2A：バックエンド連携（3週間）**

### **Phase-2A-1：Supabase基盤構築（5-7日）** 🔄 **[Git Commit]**
- [ ] Supabaseプロジェクト作成
- [ ] データベース設計・テーブル作成
- [ ] 認証機能実装
- [ ] API接続基盤実装
- [ ] データ同期機能基本実装

**成果物：**
- Supabaseセットアップ完了
- 認証システム
- API基盤

**コミットメッセージ例：** `feat: Supabase基盤構築と認証機能実装`

### **Phase-2A-2：データ永続化実装（6-8日）** 🔄 **[Git Commit]**
- [ ] プロジェクトデータ保存・読み込み
- [ ] リアルタイム同期機能
- [ ] オフライン対応
- [ ] データバックアップ機能
- [ ] バージョン管理機能

**成果物：**
- データ永続化機能
- リアルタイム同期
- オフライン対応

**コミットメッセージ例：** `feat: データ永続化とリアルタイム同期機能実装`

### **Phase-2A-3：ユーザー管理機能（4-6日）** 🔄 **[Git Commit]**
- [ ] ユーザー権限管理
- [ ] プロジェクト共有機能
- [ ] コメント・承認機能
- [ ] 変更履歴追跡
- [ ] 通知機能

**成果物：**
- 多ユーザー対応
- 権限管理システム
- コラボレーション機能

**コミットメッセージ例：** `feat: ユーザー管理と共有・承認機能実装`

### **Phase-2A-4：統合テスト・デプロイ（2-4日）** 🔄 **[Git Commit - Phase-2A完了]**
- [ ] 全機能統合テスト
- [ ] パフォーマンステスト
- [ ] セキュリティテスト
- [ ] 本番環境デプロイ
- [ ] 運用テスト

**成果物：**
- 本番デプロイ完了
- 運用開始可能状態
- 監視体制構築

**コミットメッセージ例：** `feat: Phase-2A完了 - 本番デプロイ・運用開始`

---

## **Phase-2B：将来拡張機能（継続開発）**

### **拡張機能候補**
- [ ] モバイルアプリ対応
- [ ] AI予測機能（工期予測、リスク分析）
- [ ] 外部システム連携（会計システム、発注システム）
- [ ] 高度な分析・レポート機能
- [ ] ワークフロー自動化
- [ ] 多言語対応
- [ ] カスタムテンプレート機能

---

## **各段階の評価基準・成功指標**

### **MVP成功基準** ✅ **完了済み**
- Excelファイルの正常な読み込み・出力
- 月表示でのガントチャート表示
- 基本的な操作性確保
- エラーなく動作する

### **Phase-1A-1成功基準** ✅ **完了済み**
- 全表示モード正常動作
- 表示切替UI完全機能
- レスポンシブ対応完了

### **Phase-1A-2成功基準** 🚨 **緊急実装必要（修正版）**
- **同一線上複数◆マーク表示機能**の完全実装
- **階層構造チャート表示**の正常動作
  - 第1行：総会（意思決定階層最上位）
  - 第2行：理事会（中間管理層）
  - 第3行：修繕委員会（実行層）
  - 第4行目以降：工事イベント（開始日基準）
- **時系列◆マーク配置**の正確性確保
- **会議種別データ統合処理**の完全機能
- パフォーマンス要件満足（5年データで1秒以内レスポンス）
- 依存関係矢印表示（技術課題解決後）

### **Phase-1B成功基準**
- 直感的な編集操作実現
- PDF/Excel出力品質確保
- 実運用に耐える安定性

### **Phase-2A成功基準**
- Supabase連携正常動作
- マルチユーザー同時利用可能
- データ整合性・セキュリティ確保

---

## **リスク・課題と対応策**

### **技術的リスク**
1. **Frappe Gantt制約** → カスタマイズ困難時は代替ライブラリ検討
2. **パフォーマンス問題** → 仮想化・遅延読み込み実装
3. **ブラウザ互換性** → ポリフィル・fallback実装

### **スケジュールリスク**
1. **開発遅延** → 機能優先度再評価・段階的リリース
2. **技術習得時間** → 事前学習期間確保・メンター活用

### **運用リスク**
1. **データ損失** → バックアップ・復旧手順整備
2. **セキュリティ** → 定期監査・更新計画策定

---

## **開発体制・リソース配分**

### **必要スキル・学習項目**
- **MVP**: HTML/CSS/JS基礎、Frappe Gantt、ファイル操作
- **Phase-1**: JavaScript上級、UI/UX設計、テスト手法
- **Phase-2**: Supabase、認証、API設計、セキュリティ

### **推奨開発環境**
- GitHub Codespaces
- VS Code拡張機能（Prettier, ESLint等）
- ブラウザ開発者ツール習熟
- Git/GitHub運用

---

## **成果報告・ドキュメント作成**

### **各段階で作成する文書**
1. **技術選定理由書**
2. **設計書・仕様書**
3. **テスト計画・結果報告**
4. **ユーザーマニュアル**
5. **運用・保守手順書**
6. **開発振り返り・改善提案**

---

## **Gitコミット戦略・運用方針**

### **コミットタイミング**
🔄 **[Git Commit]** マークの付いた各段階完了時に必ずコミットを実施

### **ブランチ戦略**
- **main**: 安定版（リリース可能状態）
- **develop**: 開発統合ブランチ
- **feature/**: 機能別開発ブランチ
  - `feature/mvp-basic-setup`
  - `feature/mvp-data-processing`
  - `feature/mvp-gantt-display`
  - `feature/phase1a-display-modes`
  - 等

### **コミットメッセージ規約**
```
feat: 新機能追加
fix: バグ修正
refactor: リファクタリング
test: テスト追加・修正
docs: ドキュメント更新
style: コードスタイル修正
```

### **重要マイルストーンでのタグ付け**
- `v0.1.0-mvp`: MVP完了時
- `v0.2.0-phase1a`: Phase-1A完了時
- `v1.0.0-phase1`: Phase-1完了時（本番利用可能版）
- `v2.0.0-phase2a`: Phase-2A完了時

### **復旧手順**
1. **問題発生時**: `git log --oneline` で直近のコミット確認
2. **前の安定状態に戻る**: `git reset --hard <commit-hash>`
3. **新ブランチで対策**: `git checkout -b hotfix/<issue-name>`
4. **修正後マージ**: Pull Request経由でdevelopにマージ

### **バックアップ戦略**
- 各マイルストーン完了時にGitHub上でRelease作成
- 重要ファイルの定期的なローカルバックアップ
- 開発環境全体のスナップショット（Codespaces設定含む）

このより詳細な開発計画により、各段階での具体的な作業内容と成果物が明確になり、**Gitコミットによる確実な進捗管理と障害時復旧体制**を含めた品質確保が可能になります。